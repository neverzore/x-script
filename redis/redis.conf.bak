port ${PORT}
daemonize yes   # 以后台模式运行
protected-mode no   # 集群模式下要设置成no，设置为yes的时候需要配合bind参数，只有被bind的ip能访问我们的redis

dir /home/redis/${PORT}/data # 日记、aof、rdb文件都会保存到这里 所以这个路径要是机器磁盘空间最大的（可通过df –h来获取磁盘信息）
logfile redis-${PORT}.log  # 产生的日记名
loglevel notice #日记级别（用于生产环境）

#timeout 1800    # 在客户端空闲多久后关闭连接，单位为秒。0表示永不关闭，这里的值必须大于客户端设置的连接池的最小空闲时间
#tcp-keepalive 0 # 0表示在没有通信的情况下，不会向客户端发送TCP ACK来检测客户端是否被关闭，因为在客户端有空闲检测，所以服务端没必要去检测客户端的状态

maxmemory 2gb   # redis最多能用多少内存，如果不设置的话，redis会一直消耗完系统所有的内存
maxmemory-policy volatile-lfu    # redis达到maxmemory后的内存回收策略，lfu比lru性能更好
lfu-log-factor 10
lfu-decay-time 1

dbfilename redis-${PORT}.rdb # 产生的rdb文件名
rdbcompression yes  # 开启rdb文件压缩
stop-writes-on-bgsave-error yes  # bgsave错误的时候停止写操作来保证bgsave成功
rdbchecksum yes # 检测rdb文件的完整性

appendonly yes  # 开启aof，建议主节点关闭，从节点开启
appendfsync everysec    # aof刷盘策略
auto-aof-rewrite-min-size 64mb  # 当aof文件多大的时候才进行重写
auto-aof-rewrite-percentage 100 # aof增长率
no-appendfsync-on-rewrite yes   # 在aof重写的时候时候不进行正常的aof
appendfilename redis-${PORT}.aof    # 产生的aof文件名

# 当hash的大小小于512个，并且每个值都小于64byte时，就使用ziplist存储
#hash-max-ziplist-entries 512
#hash-max-ziplist-value 64
#list-max-ziplist-size -2    # redis的list结构是quickList，每个quickList由多个quicklistNode组成，每个quicklistNode有个指针指向实际存储的zipList。这里的-2是指zipList的长度8kb，超出了这个字节数，就会新起一个ziplist
#list-compress-depth 0   # 压缩深度为0，表示zipList不压缩，不压缩的话，push/pop会快；深度为1时，表示quicklist首尾两个ziplist不压缩，其他的都压缩；如果深度为2，就表示quicklist的首尾第一个ziplist 以及首尾第二个ziplist都不压缩，其他的都压缩；以此类推
#set-max-intset-entries 512  # 当intset的元素个数达到512个后，intset升级成dict
#zset-max-ziplist-entries 128    # 与hash同理，因为set是hash的特殊情况，set的value都是null
#zset-max-ziplist-value 64

slowlog-max-len 1000    # 慢查询队列的长度
slowlog-log-slower-than 1000   # 多少时间定义为慢查询 单位微秒

cluster-enabled yes # 是否以集群的形式启动
cluster-config-file redis-nodes.conf
cluster-require-full-coverage no    # 集群中是否16384个槽都可用或所有master节点都没有问题才对外提供服务，保证集群的完整性 
cluster-node-timeout 5000    # 各个节点相互发送消息的频率，单位为毫秒。某节点发现与其他节点最后通信时间超过cluster-node-timeout/2时会发送ping命令，同时带上slots槽数组（2KB）和整个集群1/10的状态数据（10个节点的状态数据约1KB），该参数也会影响故障转移时间

client-output-buffer-limit normal 0 0 0 # 不限制普通客户端缓冲区
client-output-buffer-limit replica 512mb 128mb 60   # slave同步主节点的数据，当slave缓冲区超过512m或者缓冲区在60s秒一直处于128m以上，slave节点会被挂掉
client-output-buffer-limit pubsub 32mb 8mb 60

replica-lazy-flush yes  # 从库接收完rdb文件后的 flush操作
lazyfree-lazy-eviction yes  # 内存达到 maxmemory时进行淘汰
lazyfree-lazy-expire yes    # key过期删除
lazyfree-lazy-server-del yes    # rename指令删除destKey
